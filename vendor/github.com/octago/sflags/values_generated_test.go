package sflags

// This file is autogenerated by "go generate .". Do not modify.

import (
	"net"
	"regexp"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
)

func TestStringValue_Zero(t *testing.T) {
	nilValue := new(stringValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*stringValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestStringValue(t *testing.T) {
	t.Run("in: string", func(t *testing.T) {
		a := new(string)
		v := newStringValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("string")
		assert.Nil(t, err)
		assert.Equal(t, "string", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "string", v.Type())
	})

}

func TestStringSliceValue_Zero(t *testing.T) {
	nilValue := new(stringSliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*stringSliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestStringSliceValue(t *testing.T) {
	t.Run("in: [val1,val2 val3,val4]", func(t *testing.T) {
		var err error
		a := new([]string)
		v := newStringSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("val1,val2")
		assert.Nil(t, err)
		err = v.Set("val3,val4")
		assert.Nil(t, err)
		assert.Equal(t, "[val1,val2,val3,val4]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "stringSlice", v.Type())
	})

}

func TestBoolValue_Zero(t *testing.T) {
	nilValue := new(boolValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*boolValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestBoolValue(t *testing.T) {
	t.Run("in: true", func(t *testing.T) {
		a := new(bool)
		v := newBoolValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("true")
		assert.Nil(t, err)
		assert.Equal(t, "true", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "bool", v.Type())
	})
	t.Run("in: false", func(t *testing.T) {
		a := new(bool)
		v := newBoolValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("false")
		assert.Nil(t, err)
		assert.Equal(t, "false", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "bool", v.Type())
	})
	t.Run("in: 1", func(t *testing.T) {
		a := new(bool)
		v := newBoolValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("1")
		assert.Nil(t, err)
		assert.Equal(t, "true", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "bool", v.Type())
	})
	t.Run("in: 0", func(t *testing.T) {
		a := new(bool)
		v := newBoolValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("0")
		assert.Nil(t, err)
		assert.Equal(t, "false", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "bool", v.Type())
	})
	t.Run("in: unexpected", func(t *testing.T) {
		a := new(bool)
		v := newBoolValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("unexpected")
		assert.EqualError(t, err, "strconv.ParseBool: parsing \"unexpected\": invalid syntax")
		assert.Equal(t, "false", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "bool", v.Type())
	})

}

func TestBoolSliceValue_Zero(t *testing.T) {
	nilValue := new(boolSliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*boolSliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestBoolSliceValue(t *testing.T) {
	t.Run("in: [true,false true]", func(t *testing.T) {
		var err error
		a := new([]bool)
		v := newBoolSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("true,false")
		assert.Nil(t, err)
		err = v.Set("true")
		assert.Nil(t, err)
		assert.Equal(t, "[true,false,true]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "boolSlice", v.Type())
	})
	t.Run("in: [true,unexpected]", func(t *testing.T) {
		var err error
		a := new([]bool)
		v := newBoolSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("true,unexpected")
		assert.EqualError(t, err, "strconv.ParseBool: parsing \"unexpected\": invalid syntax")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "boolSlice", v.Type())
	})

}

func TestUintValue_Zero(t *testing.T) {
	nilValue := new(uintValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uintValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUintValue(t *testing.T) {
	t.Run("in: 18446744073709551615", func(t *testing.T) {
		a := new(uint)
		v := newUintValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("18446744073709551615")
		assert.Nil(t, err)
		assert.Equal(t, "18446744073709551615", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint", v.Type())
	})
	t.Run("in: 18446744073709551616", func(t *testing.T) {
		a := new(uint)
		v := newUintValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("18446744073709551616")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"18446744073709551616\": value out of range")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint", v.Type())
	})
	t.Run("in: -1", func(t *testing.T) {
		a := new(uint)
		v := newUintValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("-1")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint", v.Type())
	})
	t.Run("in: a", func(t *testing.T) {
		a := new(uint)
		v := newUintValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("a")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"a\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint", v.Type())
	})

}

func TestUintSliceValue_Zero(t *testing.T) {
	nilValue := new(uintSliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uintSliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUintSliceValue(t *testing.T) {
	t.Run("in: [10,20 0]", func(t *testing.T) {
		var err error
		a := new([]uint)
		v := newUintSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("10,20")
		assert.Nil(t, err)
		err = v.Set("0")
		assert.Nil(t, err)
		assert.Equal(t, "[10,20,0]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uintSlice", v.Type())
	})
	t.Run("in: [-1,0]", func(t *testing.T) {
		var err error
		a := new([]uint)
		v := newUintSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("-1,0")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uintSlice", v.Type())
	})

}

func TestUint8Value_Zero(t *testing.T) {
	nilValue := new(uint8Value)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint8Value)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint8Value(t *testing.T) {
	t.Run("in: 255", func(t *testing.T) {
		a := new(uint8)
		v := newUint8Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("255")
		assert.Nil(t, err)
		assert.Equal(t, "255", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint8", v.Type())
	})
	t.Run("in: 256", func(t *testing.T) {
		a := new(uint8)
		v := newUint8Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("256")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"256\": value out of range")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint8", v.Type())
	})
	t.Run("in: -1", func(t *testing.T) {
		a := new(uint8)
		v := newUint8Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("-1")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint8", v.Type())
	})
	t.Run("in: a", func(t *testing.T) {
		a := new(uint8)
		v := newUint8Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("a")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"a\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint8", v.Type())
	})

}

func TestUint8SliceValue_Zero(t *testing.T) {
	nilValue := new(uint8SliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint8SliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint8SliceValue(t *testing.T) {
	t.Run("in: [10,20 0]", func(t *testing.T) {
		var err error
		a := new([]uint8)
		v := newUint8SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("10,20")
		assert.Nil(t, err)
		err = v.Set("0")
		assert.Nil(t, err)
		assert.Equal(t, "[10,20,0]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint8Slice", v.Type())
	})
	t.Run("in: [-1,0]", func(t *testing.T) {
		var err error
		a := new([]uint8)
		v := newUint8SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("-1,0")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint8Slice", v.Type())
	})

}

func TestUint16Value_Zero(t *testing.T) {
	nilValue := new(uint16Value)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint16Value)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint16Value(t *testing.T) {
	t.Run("in: 65535", func(t *testing.T) {
		a := new(uint16)
		v := newUint16Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("65535")
		assert.Nil(t, err)
		assert.Equal(t, "65535", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint16", v.Type())
	})
	t.Run("in: 65536", func(t *testing.T) {
		a := new(uint16)
		v := newUint16Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("65536")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"65536\": value out of range")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint16", v.Type())
	})
	t.Run("in: -1", func(t *testing.T) {
		a := new(uint16)
		v := newUint16Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("-1")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint16", v.Type())
	})
	t.Run("in: a", func(t *testing.T) {
		a := new(uint16)
		v := newUint16Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("a")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"a\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint16", v.Type())
	})

}

func TestUint16SliceValue_Zero(t *testing.T) {
	nilValue := new(uint16SliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint16SliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint16SliceValue(t *testing.T) {
	t.Run("in: [10,20 0]", func(t *testing.T) {
		var err error
		a := new([]uint16)
		v := newUint16SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("10,20")
		assert.Nil(t, err)
		err = v.Set("0")
		assert.Nil(t, err)
		assert.Equal(t, "[10,20,0]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint16Slice", v.Type())
	})
	t.Run("in: [-1,0]", func(t *testing.T) {
		var err error
		a := new([]uint16)
		v := newUint16SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("-1,0")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint16Slice", v.Type())
	})

}

func TestUint32Value_Zero(t *testing.T) {
	nilValue := new(uint32Value)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint32Value)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint32Value(t *testing.T) {
	t.Run("in: 4294967295", func(t *testing.T) {
		a := new(uint32)
		v := newUint32Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("4294967295")
		assert.Nil(t, err)
		assert.Equal(t, "4294967295", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint32", v.Type())
	})
	t.Run("in: 4294967296", func(t *testing.T) {
		a := new(uint32)
		v := newUint32Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("4294967296")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"4294967296\": value out of range")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint32", v.Type())
	})
	t.Run("in: -1", func(t *testing.T) {
		a := new(uint32)
		v := newUint32Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("-1")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint32", v.Type())
	})
	t.Run("in: a", func(t *testing.T) {
		a := new(uint32)
		v := newUint32Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("a")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"a\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint32", v.Type())
	})

}

func TestUint32SliceValue_Zero(t *testing.T) {
	nilValue := new(uint32SliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint32SliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint32SliceValue(t *testing.T) {
	t.Run("in: [10,20 0]", func(t *testing.T) {
		var err error
		a := new([]uint32)
		v := newUint32SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("10,20")
		assert.Nil(t, err)
		err = v.Set("0")
		assert.Nil(t, err)
		assert.Equal(t, "[10,20,0]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint32Slice", v.Type())
	})
	t.Run("in: [-1,0]", func(t *testing.T) {
		var err error
		a := new([]uint32)
		v := newUint32SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("-1,0")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint32Slice", v.Type())
	})

}

func TestUint64Value_Zero(t *testing.T) {
	nilValue := new(uint64Value)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint64Value)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint64Value(t *testing.T) {
	t.Run("in: 18446744073709551615", func(t *testing.T) {
		a := new(uint64)
		v := newUint64Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("18446744073709551615")
		assert.Nil(t, err)
		assert.Equal(t, "18446744073709551615", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint64", v.Type())
	})
	t.Run("in: 18446744073709551616", func(t *testing.T) {
		a := new(uint64)
		v := newUint64Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("18446744073709551616")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"18446744073709551616\": value out of range")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint64", v.Type())
	})
	t.Run("in: -1", func(t *testing.T) {
		a := new(uint64)
		v := newUint64Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("-1")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint64", v.Type())
	})
	t.Run("in: a", func(t *testing.T) {
		a := new(uint64)
		v := newUint64Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("a")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"a\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint64", v.Type())
	})

}

func TestUint64SliceValue_Zero(t *testing.T) {
	nilValue := new(uint64SliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*uint64SliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestUint64SliceValue(t *testing.T) {
	t.Run("in: [10,20 0]", func(t *testing.T) {
		var err error
		a := new([]uint64)
		v := newUint64SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("10,20")
		assert.Nil(t, err)
		err = v.Set("0")
		assert.Nil(t, err)
		assert.Equal(t, "[10,20,0]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint64Slice", v.Type())
	})
	t.Run("in: [-1,0]", func(t *testing.T) {
		var err error
		a := new([]uint64)
		v := newUint64SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("-1,0")
		assert.EqualError(t, err, "strconv.ParseUint: parsing \"-1\": invalid syntax")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "uint64Slice", v.Type())
	})

}

func TestIntValue_Zero(t *testing.T) {
	nilValue := new(intValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*intValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIntValue(t *testing.T) {
	t.Run("in: 9223372036854775807", func(t *testing.T) {
		a := new(int)
		v := newIntValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("9223372036854775807")
		assert.Nil(t, err)
		assert.Equal(t, "9223372036854775807", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int", v.Type())
	})
	t.Run("in: -9223372036854775808", func(t *testing.T) {
		a := new(int)
		v := newIntValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("-9223372036854775808")
		assert.Nil(t, err)
		assert.Equal(t, "-9223372036854775808", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int", v.Type())
	})
	t.Run("in: 0x10", func(t *testing.T) {
		a := new(int)
		v := newIntValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("0x10")
		assert.Nil(t, err)
		assert.Equal(t, "16", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int", v.Type())
	})
	t.Run("in: 0210", func(t *testing.T) {
		a := new(int)
		v := newIntValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("0210")
		assert.Nil(t, err)
		assert.Equal(t, "136", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int", v.Type())
	})
	t.Run("in: 0710", func(t *testing.T) {
		a := new(int)
		v := newIntValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("0710")
		assert.Nil(t, err)
		assert.Equal(t, "456", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int", v.Type())
	})
	t.Run("in: -9223372036854775809", func(t *testing.T) {
		a := new(int)
		v := newIntValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("-9223372036854775809")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"-9223372036854775809\": value out of range")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int", v.Type())
	})
	t.Run("in: 9223372036854775808", func(t *testing.T) {
		a := new(int)
		v := newIntValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("9223372036854775808")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"9223372036854775808\": value out of range")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int", v.Type())
	})
	t.Run("in: a", func(t *testing.T) {
		a := new(int)
		v := newIntValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("a")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"a\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int", v.Type())
	})

}

func TestIntSliceValue_Zero(t *testing.T) {
	nilValue := new(intSliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*intSliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIntSliceValue(t *testing.T) {
	t.Run("in: [10,20 -1]", func(t *testing.T) {
		var err error
		a := new([]int)
		v := newIntSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("10,20")
		assert.Nil(t, err)
		err = v.Set("-1")
		assert.Nil(t, err)
		assert.Equal(t, "[10,20,-1]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "intSlice", v.Type())
	})
	t.Run("in: [1,a]", func(t *testing.T) {
		var err error
		a := new([]int)
		v := newIntSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("1,a")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"a\": invalid syntax")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "intSlice", v.Type())
	})

}

func TestInt8Value_Zero(t *testing.T) {
	nilValue := new(int8Value)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int8Value)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt8Value(t *testing.T) {
	t.Run("in: 127", func(t *testing.T) {
		a := new(int8)
		v := newInt8Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("127")
		assert.Nil(t, err)
		assert.Equal(t, "127", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int8", v.Type())
	})
	t.Run("in: -128", func(t *testing.T) {
		a := new(int8)
		v := newInt8Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("-128")
		assert.Nil(t, err)
		assert.Equal(t, "-128", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int8", v.Type())
	})
	t.Run("in: -129", func(t *testing.T) {
		a := new(int8)
		v := newInt8Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("-129")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"-129\": value out of range")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int8", v.Type())
	})
	t.Run("in: 128", func(t *testing.T) {
		a := new(int8)
		v := newInt8Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("128")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"128\": value out of range")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int8", v.Type())
	})
	t.Run("in: a", func(t *testing.T) {
		a := new(int8)
		v := newInt8Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("a")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"a\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int8", v.Type())
	})

}

func TestInt8SliceValue_Zero(t *testing.T) {
	nilValue := new(int8SliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int8SliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt8SliceValue(t *testing.T) {
	t.Run("in: [10,20 -1]", func(t *testing.T) {
		var err error
		a := new([]int8)
		v := newInt8SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("10,20")
		assert.Nil(t, err)
		err = v.Set("-1")
		assert.Nil(t, err)
		assert.Equal(t, "[10,20,-1]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int8Slice", v.Type())
	})
	t.Run("in: [1,a]", func(t *testing.T) {
		var err error
		a := new([]int8)
		v := newInt8SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("1,a")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"a\": invalid syntax")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int8Slice", v.Type())
	})

}

func TestInt16Value_Zero(t *testing.T) {
	nilValue := new(int16Value)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int16Value)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt16Value(t *testing.T) {
	t.Run("in: 32767", func(t *testing.T) {
		a := new(int16)
		v := newInt16Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("32767")
		assert.Nil(t, err)
		assert.Equal(t, "32767", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int16", v.Type())
	})
	t.Run("in: -32768", func(t *testing.T) {
		a := new(int16)
		v := newInt16Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("-32768")
		assert.Nil(t, err)
		assert.Equal(t, "-32768", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int16", v.Type())
	})
	t.Run("in: -32769", func(t *testing.T) {
		a := new(int16)
		v := newInt16Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("-32769")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"-32769\": value out of range")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int16", v.Type())
	})
	t.Run("in: 32768", func(t *testing.T) {
		a := new(int16)
		v := newInt16Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("32768")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"32768\": value out of range")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int16", v.Type())
	})
	t.Run("in: a", func(t *testing.T) {
		a := new(int16)
		v := newInt16Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("a")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"a\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int16", v.Type())
	})

}

func TestInt16SliceValue_Zero(t *testing.T) {
	nilValue := new(int16SliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int16SliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt16SliceValue(t *testing.T) {
	t.Run("in: [10,20 -1]", func(t *testing.T) {
		var err error
		a := new([]int16)
		v := newInt16SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("10,20")
		assert.Nil(t, err)
		err = v.Set("-1")
		assert.Nil(t, err)
		assert.Equal(t, "[10,20,-1]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int16Slice", v.Type())
	})
	t.Run("in: [1,a]", func(t *testing.T) {
		var err error
		a := new([]int16)
		v := newInt16SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("1,a")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"a\": invalid syntax")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int16Slice", v.Type())
	})

}

func TestInt32Value_Zero(t *testing.T) {
	nilValue := new(int32Value)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int32Value)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt32Value(t *testing.T) {
	t.Run("in: 2147483647", func(t *testing.T) {
		a := new(int32)
		v := newInt32Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("2147483647")
		assert.Nil(t, err)
		assert.Equal(t, "2147483647", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int32", v.Type())
	})
	t.Run("in: -2147483648", func(t *testing.T) {
		a := new(int32)
		v := newInt32Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("-2147483648")
		assert.Nil(t, err)
		assert.Equal(t, "-2147483648", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int32", v.Type())
	})
	t.Run("in: -2147483649", func(t *testing.T) {
		a := new(int32)
		v := newInt32Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("-2147483649")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"-2147483649\": value out of range")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int32", v.Type())
	})
	t.Run("in: 2147483648", func(t *testing.T) {
		a := new(int32)
		v := newInt32Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("2147483648")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"2147483648\": value out of range")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int32", v.Type())
	})
	t.Run("in: a", func(t *testing.T) {
		a := new(int32)
		v := newInt32Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("a")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"a\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int32", v.Type())
	})

}

func TestInt32SliceValue_Zero(t *testing.T) {
	nilValue := new(int32SliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int32SliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt32SliceValue(t *testing.T) {
	t.Run("in: [10,20 -1]", func(t *testing.T) {
		var err error
		a := new([]int32)
		v := newInt32SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("10,20")
		assert.Nil(t, err)
		err = v.Set("-1")
		assert.Nil(t, err)
		assert.Equal(t, "[10,20,-1]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int32Slice", v.Type())
	})
	t.Run("in: [1,a]", func(t *testing.T) {
		var err error
		a := new([]int32)
		v := newInt32SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("1,a")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"a\": invalid syntax")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int32Slice", v.Type())
	})

}

func TestInt64Value_Zero(t *testing.T) {
	nilValue := new(int64Value)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int64Value)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt64Value(t *testing.T) {
	t.Run("in: 3", func(t *testing.T) {
		a := new(int64)
		v := newInt64Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("3")
		assert.Nil(t, err)
		assert.Equal(t, "3", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int64", v.Type())
	})
	t.Run("in: -3", func(t *testing.T) {
		a := new(int64)
		v := newInt64Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("-3")
		assert.Nil(t, err)
		assert.Equal(t, "-3", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int64", v.Type())
	})
	t.Run("in: -9223372036854775809", func(t *testing.T) {
		a := new(int64)
		v := newInt64Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("-9223372036854775809")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"-9223372036854775809\": value out of range")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int64", v.Type())
	})
	t.Run("in: 9223372036854775808", func(t *testing.T) {
		a := new(int64)
		v := newInt64Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("9223372036854775808")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"9223372036854775808\": value out of range")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int64", v.Type())
	})
	t.Run("in: a", func(t *testing.T) {
		a := new(int64)
		v := newInt64Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("a")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"a\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int64", v.Type())
	})

}

func TestInt64SliceValue_Zero(t *testing.T) {
	nilValue := new(int64SliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*int64SliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestInt64SliceValue(t *testing.T) {
	t.Run("in: [10,20 -1]", func(t *testing.T) {
		var err error
		a := new([]int64)
		v := newInt64SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("10,20")
		assert.Nil(t, err)
		err = v.Set("-1")
		assert.Nil(t, err)
		assert.Equal(t, "[10,20,-1]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int64Slice", v.Type())
	})
	t.Run("in: [1,a]", func(t *testing.T) {
		var err error
		a := new([]int64)
		v := newInt64SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("1,a")
		assert.EqualError(t, err, "strconv.ParseInt: parsing \"a\": invalid syntax")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "int64Slice", v.Type())
	})

}

func TestFloat64Value_Zero(t *testing.T) {
	nilValue := new(float64Value)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*float64Value)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestFloat64Value(t *testing.T) {
	t.Run("in: 11.11", func(t *testing.T) {
		a := new(float64)
		v := newFloat64Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("11.11")
		assert.Nil(t, err)
		assert.Equal(t, "11.11", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "float64", v.Type())
	})
	t.Run("in: 11.11.11", func(t *testing.T) {
		a := new(float64)
		v := newFloat64Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("11.11.11")
		assert.EqualError(t, err, "strconv.ParseFloat: parsing \"11.11.11\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "float64", v.Type())
	})
	t.Run("in: a", func(t *testing.T) {
		a := new(float64)
		v := newFloat64Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("a")
		assert.EqualError(t, err, "strconv.ParseFloat: parsing \"a\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "float64", v.Type())
	})

}

func TestFloat64SliceValue_Zero(t *testing.T) {
	nilValue := new(float64SliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*float64SliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestFloat64SliceValue(t *testing.T) {
	t.Run("in: [10.2,20.99 3.4]", func(t *testing.T) {
		var err error
		a := new([]float64)
		v := newFloat64SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("10.2,20.99")
		assert.Nil(t, err)
		err = v.Set("3.4")
		assert.Nil(t, err)
		assert.Equal(t, "[10.2,20.99,3.4]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "float64Slice", v.Type())
	})
	t.Run("in: [1,a]", func(t *testing.T) {
		var err error
		a := new([]float64)
		v := newFloat64SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("1,a")
		assert.EqualError(t, err, "strconv.ParseFloat: parsing \"a\": invalid syntax")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "float64Slice", v.Type())
	})

}

func TestFloat32Value_Zero(t *testing.T) {
	nilValue := new(float32Value)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*float32Value)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestFloat32Value(t *testing.T) {
	t.Run("in: 11.11", func(t *testing.T) {
		a := new(float32)
		v := newFloat32Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("11.11")
		assert.Nil(t, err)
		assert.Equal(t, "11.11", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "float32", v.Type())
	})
	t.Run("in: 11.11.11", func(t *testing.T) {
		a := new(float32)
		v := newFloat32Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("11.11.11")
		assert.EqualError(t, err, "strconv.ParseFloat: parsing \"11.11.11\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "float32", v.Type())
	})
	t.Run("in: a", func(t *testing.T) {
		a := new(float32)
		v := newFloat32Value(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("a")
		assert.EqualError(t, err, "strconv.ParseFloat: parsing \"a\": invalid syntax")
		assert.Equal(t, "0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "float32", v.Type())
	})

}

func TestFloat32SliceValue_Zero(t *testing.T) {
	nilValue := new(float32SliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*float32SliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestFloat32SliceValue(t *testing.T) {
	t.Run("in: [10.2,20.99 3.4]", func(t *testing.T) {
		var err error
		a := new([]float32)
		v := newFloat32SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("10.2,20.99")
		assert.Nil(t, err)
		err = v.Set("3.4")
		assert.Nil(t, err)
		assert.Equal(t, "[10.2,20.99,3.4]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "float32Slice", v.Type())
	})
	t.Run("in: [1,a]", func(t *testing.T) {
		var err error
		a := new([]float32)
		v := newFloat32SliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("1,a")
		assert.EqualError(t, err, "strconv.ParseFloat: parsing \"a\": invalid syntax")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "float32Slice", v.Type())
	})

}

func TestDurationValue_Zero(t *testing.T) {
	nilValue := new(durationValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*durationValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestDurationValue(t *testing.T) {
	t.Run("in: 3s", func(t *testing.T) {
		a := new(time.Duration)
		v := newDurationValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("3s")
		assert.Nil(t, err)
		assert.Equal(t, "3s", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "duration", v.Type())
	})
	t.Run("in: 3l", func(t *testing.T) {
		a := new(time.Duration)
		v := newDurationValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("3l")
		assert.EqualError(t, err, "time: unknown unit l in duration 3l")
		assert.Equal(t, "0s", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "duration", v.Type())
	})

}

func TestDurationSliceValue_Zero(t *testing.T) {
	nilValue := new(durationSliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*durationSliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestDurationSliceValue(t *testing.T) {
	t.Run("in: [10s,30m 1ms]", func(t *testing.T) {
		var err error
		a := new([]time.Duration)
		v := newDurationSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("10s,30m")
		assert.Nil(t, err)
		err = v.Set("1ms")
		assert.Nil(t, err)
		assert.Equal(t, "[10s,30m0s,1ms]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "durationSlice", v.Type())
	})
	t.Run("in: [1s,3l]", func(t *testing.T) {
		var err error
		a := new([]time.Duration)
		v := newDurationSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("1s,3l")
		assert.EqualError(t, err, "time: unknown unit l in duration 3l")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "durationSlice", v.Type())
	})

}

func TestIPValue_Zero(t *testing.T) {
	nilValue := new(ipValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*ipValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIPValue(t *testing.T) {
	t.Run("in: 127.0.0.1", func(t *testing.T) {
		a := new(net.IP)
		v := newIPValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("127.0.0.1")
		assert.Nil(t, err)
		assert.Equal(t, "127.0.0.1", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "ip", v.Type())
	})
	t.Run("in: 127.0.0.1.3", func(t *testing.T) {
		a := new(net.IP)
		v := newIPValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("127.0.0.1.3")
		assert.EqualError(t, err, "failed to parse IP: \"127.0.0.1.3\"")
		assert.Equal(t, "<nil>", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "ip", v.Type())
	})

}

func TestIPSliceValue_Zero(t *testing.T) {
	nilValue := new(ipSliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*ipSliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIPSliceValue(t *testing.T) {
	t.Run("in: [127.0.0.1,127.0.0.2 127.0.0.3]", func(t *testing.T) {
		var err error
		a := new([]net.IP)
		v := newIPSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("127.0.0.1,127.0.0.2")
		assert.Nil(t, err)
		err = v.Set("127.0.0.3")
		assert.Nil(t, err)
		assert.Equal(t, "[127.0.0.1,127.0.0.2,127.0.0.3]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "ipSlice", v.Type())
	})
	t.Run("in: [127.0.0.3,127.0.0.1.3]", func(t *testing.T) {
		var err error
		a := new([]net.IP)
		v := newIPSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("127.0.0.3,127.0.0.1.3")
		assert.EqualError(t, err, "failed to parse IP: \"127.0.0.1.3\"")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "ipSlice", v.Type())
	})

}

func TestHexBytesValue_Zero(t *testing.T) {
	nilValue := new(hexBytesValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*hexBytesValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestHexBytesValue(t *testing.T) {
	t.Run("in: ffffff", func(t *testing.T) {
		a := new(HexBytes)
		v := newHexBytesValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("ffffff")
		assert.Nil(t, err)
		assert.Equal(t, "ffffff", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "hexBytes", v.Type())
	})
	t.Run("in: FFFFFF", func(t *testing.T) {
		a := new(HexBytes)
		v := newHexBytesValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("FFFFFF")
		assert.Nil(t, err)
		assert.Equal(t, "ffffff", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "hexBytes", v.Type())
	})
	t.Run("in: g", func(t *testing.T) {
		a := new(HexBytes)
		v := newHexBytesValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("g")
		assert.EqualError(t, err, "encoding/hex: odd length hex string")
		assert.Equal(t, "", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "hexBytes", v.Type())
	})
	t.Run("in: gg", func(t *testing.T) {
		a := new(HexBytes)
		v := newHexBytesValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("gg")
		assert.EqualError(t, err, "encoding/hex: invalid byte: U+0067 'g'")
		assert.Equal(t, "", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "hexBytes", v.Type())
	})

}

func TestHexBytesSliceValue_Zero(t *testing.T) {
	nilValue := new(hexBytesSliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*hexBytesSliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestHexBytesSliceValue(t *testing.T) {
	t.Run("in: [ff,aa,bb cc]", func(t *testing.T) {
		var err error
		a := new([]HexBytes)
		v := newHexBytesSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("ff,aa,bb")
		assert.Nil(t, err)
		err = v.Set("cc")
		assert.Nil(t, err)
		assert.Equal(t, "[ff,aa,bb,cc]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "hexBytesSlice", v.Type())
	})
	t.Run("in: [ff,gg]", func(t *testing.T) {
		var err error
		a := new([]HexBytes)
		v := newHexBytesSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("ff,gg")
		assert.EqualError(t, err, "encoding/hex: invalid byte: U+0067 'g'")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "hexBytesSlice", v.Type())
	})

}

func TestRegexpValue_Zero(t *testing.T) {
	nilValue := new(regexpValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*regexpValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestRegexpValue(t *testing.T) {
	t.Run("in: abcdef.*", func(t *testing.T) {
		a := new(regexp.Regexp)
		v := newRegexpValue(&a)
		assert.Equal(t, parseGeneratedPtrs(&a), v)
		err := v.Set("abcdef.*")
		assert.Nil(t, err)
		assert.Equal(t, "abcdef.*", v.String())
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "regexp", v.Type())
	})
	t.Run("in: [abc", func(t *testing.T) {
		a := new(regexp.Regexp)
		v := newRegexpValue(&a)
		assert.Equal(t, parseGeneratedPtrs(&a), v)
		err := v.Set("[abc")
		assert.EqualError(t, err, "error parsing regexp: missing closing ]: `[abc`")
		assert.Equal(t, "", v.String())
		assert.Equal(t, a, v.Get())
		assert.Equal(t, "regexp", v.Type())
	})

}

func TestRegexpSliceValue_Zero(t *testing.T) {
	nilValue := new(regexpSliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*regexpSliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestRegexpSliceValue(t *testing.T) {
	t.Run("in: [abc.*,def.* xyz.*]", func(t *testing.T) {
		var err error
		a := new([]*regexp.Regexp)
		v := newRegexpSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("abc.*,def.*")
		assert.Nil(t, err)
		err = v.Set("xyz.*")
		assert.Nil(t, err)
		assert.Equal(t, "[abc.*,def.*,xyz.*]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "regexpSlice", v.Type())
	})
	t.Run("in: [[abc,def]", func(t *testing.T) {
		var err error
		a := new([]*regexp.Regexp)
		v := newRegexpSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("[abc,def")
		assert.EqualError(t, err, "error parsing regexp: missing closing ]: `[abc`")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "regexpSlice", v.Type())
	})

}

func TestTCPAddrValue_Zero(t *testing.T) {
	nilValue := new(tcpAddrValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*tcpAddrValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestTCPAddrValue(t *testing.T) {
	t.Run("in: 127.0.0.1:8000", func(t *testing.T) {
		a := new(net.TCPAddr)
		v := newTCPAddrValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("127.0.0.1:8000")
		assert.Nil(t, err)
		assert.Equal(t, "127.0.0.1:8000", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "tcpAddr", v.Type())
	})
	t.Run("in: localhost:80", func(t *testing.T) {
		a := new(net.TCPAddr)
		v := newTCPAddrValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("localhost:80")
		assert.Nil(t, err)
		assert.Equal(t, "127.0.0.1:80", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "tcpAddr", v.Type())
	})
	t.Run("in: 127.0.0.1", func(t *testing.T) {
		a := new(net.TCPAddr)
		v := newTCPAddrValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("127.0.0.1")
		assert.EqualError(t, err, "failed to parse TCPAddr: \"127.0.0.1\"")
		assert.Equal(t, ":0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "tcpAddr", v.Type())
	})
	t.Run("in: 127.0.0.1.3:8000", func(t *testing.T) {
		a := new(net.TCPAddr)
		v := newTCPAddrValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("127.0.0.1.3:8000")
		assert.EqualError(t, err, "failed to parse TCPAddr: \"127.0.0.1.3:8000\"")
		assert.Equal(t, ":0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "tcpAddr", v.Type())
	})

}

func TestTCPAddrSliceValue_Zero(t *testing.T) {
	nilValue := new(tcpAddrSliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*tcpAddrSliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestTCPAddrSliceValue(t *testing.T) {
	t.Run("in: [127.0.0.1:80,127.0.0.2:80 127.0.0.3:8800]", func(t *testing.T) {
		var err error
		a := new([]net.TCPAddr)
		v := newTCPAddrSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("127.0.0.1:80,127.0.0.2:80")
		assert.Nil(t, err)
		err = v.Set("127.0.0.3:8800")
		assert.Nil(t, err)
		assert.Equal(t, "[127.0.0.1:80,127.0.0.2:80,127.0.0.3:8800]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "tcpAddrSlice", v.Type())
	})
	t.Run("in: [127.0.0.3:8000,127.0.0.1.3:8000]", func(t *testing.T) {
		var err error
		a := new([]net.TCPAddr)
		v := newTCPAddrSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("127.0.0.3:8000,127.0.0.1.3:8000")
		assert.EqualError(t, err, "failed to parse TCPAddr: \"127.0.0.1.3:8000\"")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "tcpAddrSlice", v.Type())
	})

}

func TestIPNetValue_Zero(t *testing.T) {
	nilValue := new(ipNetValue)
	assert.Equal(t, "", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*ipNetValue)(nil)
	assert.Equal(t, "", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIPNetValue(t *testing.T) {
	t.Run("in: 0.0.0.0/0", func(t *testing.T) {
		a := new(net.IPNet)
		v := newIPNetValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("0.0.0.0/0")
		assert.Nil(t, err)
		assert.Equal(t, "0.0.0.0/0", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "ipNet", v.Type())
	})
	t.Run("in: 1.2.3.4/8", func(t *testing.T) {
		a := new(net.IPNet)
		v := newIPNetValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("1.2.3.4/8")
		assert.Nil(t, err)
		assert.Equal(t, "1.0.0.0/8", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "ipNet", v.Type())
	})
	t.Run("in: 255.255.255.255/19", func(t *testing.T) {
		a := new(net.IPNet)
		v := newIPNetValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("255.255.255.255/19")
		assert.Nil(t, err)
		assert.Equal(t, "255.255.224.0/19", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "ipNet", v.Type())
	})
	t.Run("in: 255.255.255.255/32", func(t *testing.T) {
		a := new(net.IPNet)
		v := newIPNetValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("255.255.255.255/32")
		assert.Nil(t, err)
		assert.Equal(t, "255.255.255.255/32", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "ipNet", v.Type())
	})
	t.Run("in: ", func(t *testing.T) {
		a := new(net.IPNet)
		v := newIPNetValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("")
		assert.EqualError(t, err, "invalid CIDR address: ")
		assert.Equal(t, "<nil>", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "ipNet", v.Type())
	})
	t.Run("in: 0.0.0.256/16", func(t *testing.T) {
		a := new(net.IPNet)
		v := newIPNetValue(a)
		assert.Equal(t, parseGenerated(a), v)
		err := v.Set("0.0.0.256/16")
		assert.EqualError(t, err, "invalid CIDR address: 0.0.0.256/16")
		assert.Equal(t, "<nil>", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "ipNet", v.Type())
	})

}

func TestIPNetSliceValue_Zero(t *testing.T) {
	nilValue := new(ipNetSliceValue)
	assert.Equal(t, "[]", nilValue.String())
	assert.Nil(t, nilValue.Get())
	nilObj := (*ipNetSliceValue)(nil)
	assert.Equal(t, "[]", nilObj.String())
	assert.Nil(t, nilObj.Get())
}

func TestIPNetSliceValue(t *testing.T) {
	t.Run("in: [0.0.0.0/0,1.2.3.4/8 255.255.255.255/19]", func(t *testing.T) {
		var err error
		a := new([]net.IPNet)
		v := newIPNetSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("0.0.0.0/0,1.2.3.4/8")
		assert.Nil(t, err)
		err = v.Set("255.255.255.255/19")
		assert.Nil(t, err)
		assert.Equal(t, "[0.0.0.0/0,1.0.0.0/8,255.255.224.0/19]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "ipNetSlice", v.Type())
	})
	t.Run("in: [0.0.0.0/0,0.0.0.256/16]", func(t *testing.T) {
		var err error
		a := new([]net.IPNet)
		v := newIPNetSliceValue(a)
		assert.Equal(t, parseGenerated(a), v)
		assert.True(t, v.IsCumulative())
		err = v.Set("0.0.0.0/0,0.0.0.256/16")
		assert.EqualError(t, err, "invalid CIDR address: 0.0.0.256/16")
		assert.Equal(t, "[]", v.String())
		assert.Equal(t, *a, v.Get())
		assert.Equal(t, "ipNetSlice", v.Type())
	})

}
